import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
const RATEHAWK_KEY_ID = Deno.env.get('RATEHAWK_KEY_ID');
const RATEHAWK_API_KEY = Deno.env.get('RATEHAWK_API_KEY');
const RATEHAWK_API_URL = Deno.env.get('RATEHAWK_API_URL') || 'https://api.worldota.net';
const SUPABASE_URL = Deno.env.get('SUPABASE_URL');
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, OPTIONS'
};
async function logApiCall(supabase, endpoint, requestData, responseData, responseStatus, startTime, error) {
  const responseTime = Date.now() - startTime;
  try {
    await supabase.from('ratehawk_api_logs').insert({
      endpoint,
      method: 'POST',
      request_data: requestData,
      response_data: responseData,
      response_status: responseStatus,
      response_time_ms: responseTime,
      error: error || null
    });
  } catch (logError) {
    console.error('Failed to log API call:', logError);
  }
}
async function createBookingForm(request, supabase) {
  const startTime = Date.now();
  const endpoint = '/api/b2b/v3/hotel/order/booking/form/';
  const requestBody = {
    partner_order_id: request.partnerOrderId,
    book_hash: request.bookHash,
    language: request.language || 'en',
    user_ip: request.userIp
  };
  console.log(`[Booking Form] Partner Order ID: ${request.partnerOrderId}`);
  console.log(`[Booking Form] Book Hash: ${request.bookHash}`);
  console.log(`[Booking Form] User IP: ${request.userIp}`);
  try {
    const authString = `${RATEHAWK_KEY_ID}:${RATEHAWK_API_KEY}`;
    const encodedAuth = btoa(authString);
    const response = await fetch(`${RATEHAWK_API_URL}${endpoint}`, {
      method: 'POST',
      headers: {
        'Authorization': `Basic ${encodedAuth}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(requestBody)
    });
    const data = await response.json();
    await logApiCall(supabase, endpoint, requestBody, data, response.status, startTime, response.ok ? undefined : 'API Error');
    if (!response.ok) {
      console.error('[Booking Form] API Error:', data);
      // Handle specific errors
      if (data.error === 'double_booking_form') {
        throw new Error('This partner_order_id is already in use. Please generate a new unique ID.');
      }
      if (data.error === 'duplicate_reservation') {
        throw new Error('A booking with this partner_order_id already exists.');
      }
      if (data.error === 'rate_not_found') {
        throw new Error('Rate expired or not found. Please search again.');
      }
      throw new Error(data.error?.message || JSON.stringify(data));
    }
    console.log(`[Booking Form] Success: Order ID ${data.data?.order_id}`);
    return formatBookingFormResponse(data, request);
  } catch (error) {
    console.error('[Booking Form] Error:', error);
    await logApiCall(supabase, endpoint, requestBody, null, 0, startTime, error.message);
    throw error;
  }
}
function formatBookingFormResponse(rawData, request) {
  const formData = rawData.data;
  const hasError = rawData.error !== null && rawData.error !== undefined;
  if (hasError) {
    return {
      success: false,
      error: {
        code: rawData.error,
        message: getErrorMessage(rawData.error),
        status: rawData.status
      },
      _rawResponse: rawData
    };
  }
  return {
    success: true,
    // CRITICAL: Save these for booking finish step
    orderId: formData.order_id,
    itemId: formData.item_id,
    partnerOrderId: formData.partner_order_id,
    // Payment information
    paymentTypes: formData.payment_types || [],
    // Additional info
    isGenderRequired: formData.is_gender_specification_required || false,
    upsellData: formData.upsell_data || [],
    // Lifetime warning
    expiresIn: '60 minutes',
    _rawResponse: rawData
  };
}
function getErrorMessage(errorCode) {
  const errorMessages = {
    'contract_mismatch': 'Rate found with different contract.',
    'double_booking_form': 'This partner_order_id is already in use. Generate a new unique ID.',
    'duplicate_reservation': 'A completed booking with this partner_order_id already exists.',
    'hotel_not_found': 'Hotel not found.',
    'reservation_is_not_allowed': 'No permission to book. Contact account manager.',
    'rate_not_found': 'Rate expired or not found. Please search again.',
    'sandbox_restriction': 'Cannot book real hotel in test environment.',
    'timeout': 'Request timeout. Try again.',
    'unknown': 'Unknown error. Try again.'
  };
  return errorMessages[errorCode] || 'Unknown error occurred';
}
serve(async (req)=>{
  if (req.method === 'OPTIONS') {
    return new Response('ok', {
      headers: corsHeaders
    });
  }
  try {
    const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);
    const request = await req.json();
    console.log('[Booking Form] Received request');
    // Validation
    if (!request.bookHash) {
      throw new Error('bookHash is required');
    }
    if (!request.partnerOrderId) {
      throw new Error('partnerOrderId is required (must be unique UUID)');
    }
    if (!request.userIp) {
      throw new Error('userIp is required');
    }
    const result = await createBookingForm(request, supabase);
    return new Response(JSON.stringify(result), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json'
      },
      status: 200
    });
  } catch (error) {
    console.error('[Booking Form] Handler error:', error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message,
      details: error.toString()
    }), {
      headers: {
        ...corsHeaders,
        'Content-Type': 'application/json'
      },
      status: 500
    });
  }
});
