Goal

Fetch MANY combined round-trip offers from Duffel (limit 50+) with proper cursor pagination.

Display outbound and inbound lists with prices by grouping the combined offers, not by showing naked slices.

Keep the selection flow: user picks outbound → inbound → we already have the exact combined offer (no reprice required).

Changes

Backend search (Edge Function / server route)

Use Duffel /air/offer_requests with two slices (outbound + return).

Then fetch /air/offer_requests/{id}/offers?limit=50&sort=total_amount

If response has meta.after, expose it in the API so the client can “Load more” (call again with after and append).

Do not pre-filter beyond user query. No client-side hard caps.

Return shape:

{
  offers: DuffelOffer[],   // full offers with both slices
  after?: string           // Duffel cursor if more results
}


Client search page – group combined offers into outbound/inbound options

Build a stable key for slice 0 (“outbound”) and slice 1 (“return”). Example:

function sliceKey(slice) {
  const seg = slice.segments;
  return [
    seg[0].origin.iata_code,
    seg.at(-1).destination.iata_code,
    seg[0].departing_at,
    seg.map(s => s.marketing_carrier.iata_code + s.marketing_carrier_flight_number).join('-')
  ].join('|');
}


From the offers array:

Create a map byOutboundKey: { [key: string]: { sampleSlice: Slice, options: Array<{ inboundKey, offer, inboundSlice }> } }

For each offer:

ok = sliceKey(offer.slices[0])

ik = sliceKey(offer.slices[1])

Push { inboundKey: ik, offer, inboundSlice: offer.slices[1] } into byOutboundKey[ok].options

Outbound list UI: show one card per ok (use sampleSlice for times/carrier). Price shown = min total across its options:

const minPrice = Math.min(...group.options.map(o => Number(o.offer.total_amount)));


Return list UI: when user selects an outbound ok, render all inbound options from that group; each row shows the return slice timings and the offer.total_amount / total_currency from its paired offer. That’s the real round-trip price for that combination.

The “Select Flight” button on an inbound row should persist that exact offer (full offer JSON) to cart_sessions via /api/cart/select and move to review.

Pagination UI (load more)

If backend returns after, show a “Load more results” button; on click, call the same search endpoint with ?after=... and append offers to the current list, then re-run the grouping.

Acceptance checks

Outbound list > 4 options on busy routes (depends on inventory, but not hard-capped).

Each inbound row shows a price (the combined offer’s total_amount).

Selecting inbound writes the full offer to cart and review/ancillaries show both slices and the correct total.

Implementation hints

Backend snippet (TypeScript, pseudo):

const req = await fetch('https://api.duffel.com/air/offer_requests', {
  method: 'POST',
  headers: {
    Authorization: `Bearer ${process.env.DUFFEL_API_KEY}`,
    'Duffel-Version': 'v1',
    'Content-Type': 'application/json',
    Accept: 'application/json'
  },
  body: JSON.stringify({
    slices: [
      { origin: from, destination: to, departure_date: outDate },
      { origin: to, destination: from, departure_date: retDate }
    ],
    passengers: [{ type: 'adult' }],
    cabin_class: cabin
  })
});
const reqData = await req.json();

const url = new URL(`https://api.duffel.com/air/offer_requests/${reqData.data.id}/offers`);
url.searchParams.set('limit', '50');
if (after) url.searchParams.set('after', after);
url.searchParams.set('sort', 'total_amount'); // cheapest first

const offersRes = await fetch(url, { headers: { Authorization: `Bearer ${process.env.DUFFEL_API_KEY}`, Accept: 'application/json' }});
const offersJson = await offersRes.json();
return json({ offers: offersJson.data, after: offersJson.meta?.after });


Client grouping (sketch):

const groups = new Map<string, { sampleSlice: any, options: any[] }>();
for (const offer of offers) {
  const out = offer.slices[0], ret = offer.slices[1];
  const ok = sliceKey(out), ik = sliceKey(ret);
  if (!groups.has(ok)) groups.set(ok, { sampleSlice: out, options: [] });
  groups.get(ok)!.options.push({ inboundKey: ik, inboundSlice: ret, offer });
}
const outboundGroups = [...groups.entries()].map(([key, g]) => ({
  key, sample: g.sampleSlice,
  minPrice: Math.min(...g.options.map(o => +o.offer.total_amount)),
  currency: g.options[0]?.offer.total_currency,
  options: g.options
}));


Inbound row “Select Flight” handler:

await fetch('/api/cart/select', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ session_id, offer: selectedOption.offer })
});
router.push(`/review?sid=${session_id}`);


Review/Ancillaries: render offer.slices[0] under “Outbound” and offer.slices[1] under “Return”; price = offer.total_amount.

Please implement the above now: replace any remaining per-slice pricing logic, wire cursor pagination, and confirm that more than 4 outbound options show where available and that return rows display the correct total price per combination.